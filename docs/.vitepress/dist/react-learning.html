<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>个人笔记 | 个人笔记</title>
    <meta name="description" content="12312312">
    <link rel="stylesheet" href="/assets/style.1dea14ef.css">
    <link rel="modulepreload" href="/assets/app.e3fac29c.js">
    <link rel="modulepreload" href="/assets/react-learning.md.fd19e56c.lean.js">
    
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f44a984a><!--[--><!--]--><!--[--><span tabindex="-1" data-v-151f2593></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-151f2593> Skip to content </a><!--]--><!----><header class="VPNav" data-v-f44a984a data-v-a50780ff><div class="VPNavBar has-sidebar" data-v-a50780ff data-v-6f1d18b5><div class="container" data-v-6f1d18b5><div class="VPNavBarTitle has-sidebar" data-v-6f1d18b5 data-v-d5925166><a class="title" href="/" data-v-d5925166><!--[--><!--]--><!----><!--[-->个人笔记<!--]--><!--[--><!--]--></a></div><div class="content" data-v-6f1d18b5><!--[--><!--]--><!----><!----><!----><div class="VPNavBarAppearance appearance" data-v-6f1d18b5 data-v-a3e7452b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-a3e7452b data-v-481098f9 data-v-eba7420e><span class="check" data-v-eba7420e><span class="icon" data-v-eba7420e><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-481098f9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-481098f9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6f1d18b5 data-v-738bef5a data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/zhangxin187" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6f1d18b5 data-v-e4361c82 data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6ffb57d3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6ffb57d3><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><!----><!--[--><!--[--><!----><div class="group" data-v-e4361c82><div class="item appearance" data-v-e4361c82><p class="label" data-v-e4361c82>Appearance</p><div class="appearance-action" data-v-e4361c82><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-e4361c82 data-v-481098f9 data-v-eba7420e><span class="check" data-v-eba7420e><span class="icon" data-v-eba7420e><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-481098f9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-481098f9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-e4361c82><div class="item social-links" data-v-e4361c82><div class="VPSocialLinks social-links-list" data-v-e4361c82 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/zhangxin187" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6f1d18b5 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-f44a984a data-v-b6162a8b><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-b6162a8b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-b6162a8b><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-b6162a8b>Menu</span></button><a class="top-link" href="#" data-v-b6162a8b> Return to top </a></div><aside class="VPSidebar" data-v-f44a984a data-v-a186aa16><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a186aa16><span class="visually-hidden" id="sidebar-aria-label" data-v-a186aa16> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-a186aa16><section class="VPSidebarGroup collapsible" data-v-a186aa16 data-v-6e45c352><div class="title" role="button" data-v-6e45c352><h2 class="title-text" data-v-6e45c352>React</h2><div class="action" data-v-6e45c352><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-6e45c352><!--[--><!--[--><a class="VPLink link link" href="/blog/react-learning.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>React知识点</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-a186aa16><section class="VPSidebarGroup collapsible" data-v-a186aa16 data-v-6e45c352><div class="title" role="button" data-v-6e45c352><h2 class="title-text" data-v-6e45c352>Vue</h2><div class="action" data-v-6e45c352><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-6e45c352><!--[--><!--[--><a class="VPLink link link" href="/blog/vue-learning.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>Vue知识点</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><div class="group" data-v-a186aa16><section class="VPSidebarGroup collapsible" data-v-a186aa16 data-v-6e45c352><div class="title" role="button" data-v-6e45c352><h2 class="title-text" data-v-6e45c352>面试问题总结</h2><div class="action" data-v-6e45c352><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-6e45c352><!--[--><!--[--><a class="VPLink link link" href="/blog/other-learning.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>前端</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f44a984a data-v-d981fe29><div class="VPDoc has-sidebar has-aside" data-v-d981fe29 data-v-cfb513e0><div class="container" data-v-cfb513e0><div class="aside" data-v-cfb513e0><div class="aside-curtain" data-v-cfb513e0></div><div class="aside-container" data-v-cfb513e0><div class="aside-content" data-v-cfb513e0><div class="VPDocAside" data-v-cfb513e0 data-v-afc4c1a1><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-afc4c1a1 data-v-2865c0b0><div class="content" data-v-2865c0b0><div class="outline-marker" data-v-2865c0b0></div><div class="outline-title" data-v-2865c0b0>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-2865c0b0><span class="visually-hidden" id="doc-outline-aria-label" data-v-2865c0b0> Table of Contents for current page </span><ul class="root" data-v-2865c0b0 data-v-1188541a><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-afc4c1a1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-cfb513e0><div class="content-container" data-v-cfb513e0><!--[--><!--]--><main class="main" data-v-cfb513e0><div style="position:relative;" class="vp-doc _react-learning" data-v-cfb513e0><div><meta name="referrer" content="no-referrer"><p><a name="yc9pr"></a></p><h2 id="_1-react理念" tabindex="-1">1.React理念 <a class="header-anchor" href="#_1-react理念" aria-hidden="true">#</a></h2><p>React为了践行“<strong>构建快速响应的大型 Web 应用程序</strong>”理念做出的努力。<br>其中的关键是解决<strong>CPU的瓶颈</strong>与<strong>IO的瓶颈</strong>。而落实到实现上，则需要<strong>将同步的更新变为可中断的异步更新。</strong></p><p><strong>何为异步可中断更新？</strong><br>在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件。<br>当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续执行被中断的工作。<br><strong>更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</strong></p><p><a name="uGQz7"></a></p><h3 id="react15的缺点" tabindex="-1">react15的缺点 <a class="header-anchor" href="#react15的缺点" aria-hidden="true">#</a></h3><p>React从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650089477183-8aa35c61-da78-46ea-9594-82060e15bec7.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650089611932-4a522269-756b-4d71-9f26-e0b2a54f2f70.png" alt="image.png"><br><strong>总结：</strong><br><strong>Reconciler和Renderer是同步交替执行的</strong>，Reconciler会递归虚拟DOM树，发现有需要变更的DOM，便立即会通知Renderer去执行DOM更新，依次递归查找下去。故它<strong>无法实现异步可中断的更新</strong>，当虚拟DOM树比较深时，<strong>需要更新的DOM比较多时，页面会造成卡顿。</strong></p><p><a name="QhmeS"></a></p><h3 id="新的react16架构" tabindex="-1">新的react16架构 <a class="header-anchor" href="#新的react16架构" aria-hidden="true">#</a></h3><p>由于React15架构不能支撑异步更新以至于需要重构。<br>React16架构新增了Scheduler（调度器）， 调度任务的优先级，高优任务优先进入Reconciler。<br>重构了Reconciler，将递归处理虚拟DOM，变为了<strong>可中断的循环</strong>，内部采用<strong>Fiber架构</strong>。 <a name="Au9Nk"></a><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650090440348-3d474beb-4235-4f6a-a0aa-88f0d09db4b8.png" alt="image.png"><a name="o2eFt"></a></p><h2 id="_2-fiber" tabindex="-1">2. fiber <a class="header-anchor" href="#_2-fiber" aria-hidden="true">#</a></h2><p><a name="HbewI"></a></p><h2 id="" tabindex="-1"><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650090518331-7c8d590c-7a3e-435c-9ae2-3a67dccebbb1.png" alt="image.png"> <a class="header-anchor" href="#" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650090583602-00db474b-f5be-4cdd-8110-f5fb9a885ae0.png" alt="image.png"><br><strong>总结：</strong><br>fiber是React16引入的概念，它有两层含义：</p><ol><li>fiber节点就是VNode的进阶版本，fiber节点是在VNode基础上，新增了一些属性，在VNode上打上了标记，如增删改查的属性，commit时，renerer就知道如何操作DOM了。</li><li>从架构层面来说，在reconciler中通过使用fiber，可以完成<strong>操作中断与恢复</strong>，并且恢复之后可以复用之前的<strong>中间状态</strong>，它是<strong>react内部实现的一套状态更新机制</strong>。当有高优先级任务时，执行的过程中可以中断任务，转而执行高优先级任务，当预留时间不够时，可以中断执行，将线程的执行权交出去。这样一种机制就叫做<strong>fiber</strong>(纤程)。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650702667124-b4daa010-ca9b-4ea4-8434-184c3740a96c.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650703773290-a612ff56-c17c-4d23-bc2b-290826d74d2c.png" alt="image.png"><strong>fiber将render阶段中的diff(渲染)进行分片，当预留的时间不够时，停止render，让出主线程执行权，交给渲染线程执行。</strong></p><p><a name="Py7hG"></a></p><h2 id="_3-为何不用generator而创造fiber" tabindex="-1">3. 为何不用generator而创造fiber？ <a class="header-anchor" href="#_3-为何不用generator而创造fiber" aria-hidden="true">#</a></h2><p><strong>fiber实现了操作的中断与恢复</strong>，继续执行时复用之前执行的中间状态**。<strong>它类似于协程。<br>而在js中</strong>Generator**就是一种协程的实现，它可以中断函数的执行，将线程控制权交出去，然后可以接着上一次中断的地方接着执行。它跟fiber其实是一样的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650091449655-6e098273-624d-442f-aaac-6b9627965639.png" alt="image.png"></p><ul><li>generator具有传染性</li><li>generator无法实现<strong>高优先级任务插队</strong>，它的中间态是上下文关联的，当有高级先级任务插队时**，需要重新计算上下文的中间状态。**</li></ul><p><a name="XKIvP"></a></p><h2 id="_4-element、component-vnode、jsx对象、fiber节点-的区别" tabindex="-1">4. (element、component)(VNode、jsx对象、fiber节点)的区别 <a class="header-anchor" href="#_4-element、component-vnode、jsx对象、fiber节点-的区别" aria-hidden="true">#</a></h2><p>我们知道写的JSX，最终会被<code>babel</code>编译为<code>React.createElement</code>方法。<br><code>createElement</code>返回一个包含组件数据的对象，我们称之为 <code>element</code>，也可以叫做<code>VNode</code>(虚拟DOM)，或者为<code>JSX对象</code>。<br><code>component</code>就是一个组件，可以是函数组件、class组件，它是作为<code>type</code>属性传入<code>createElement</code>中去的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650092428825-109574cd-5f38-454b-93ac-8b5e47b978ff.png" alt="image.png"><br>fiber节点拥有比VNode更多的信息，VNode仅仅描述了DOM结构，而fiber包含有Scheduler、Reconciler、Render等相关的信息。</p><p><a name="PSiAM"></a></p><h2 id="_5-fiber双缓存" tabindex="-1">5.fiber双缓存 <a class="header-anchor" href="#_5-fiber双缓存" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650163087190-7dc2a353-fc32-4196-874d-d375a109f9fe.png" alt="image.png"><br>React只有一个根节点，就是<code>fiberRootNode</code>，整个应用的根节点，而组件的根节点是<code>rootFIber</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650163144564-a5e6bc7f-0e99-4080-b520-65977edda3fa.png" alt="image.png"><br>在react中同时存在两棵fiber树，页面中渲染的为<code>currentFiber树</code>，内存中(<code>reconciler中</code>)正在构建的是<code>workInProgress Fiber树</code>，在commit阶段（<code>renderer中</code>），将<code>fiberRootNode</code>的current指向<code>workInProgress树</code>，它变为<code>currentFiber树</code>，渲染在页面上。</p><p><a name="o2X3E"></a></p><h2 id="_6-render流程" tabindex="-1">6. render流程 <a class="header-anchor" href="#_6-render流程" aria-hidden="true">#</a></h2><p>Reconciler执行的过程称为<strong>render阶段</strong>，Renderer执行过程称为<strong>commit阶段</strong>。相较于Vue的话，这两个阶段就为render 和 patch。</p><p>我们知道<code>Fiber Reconciler</code>是<code>从Stack Reconciler</code>重构而来，通过<strong>遍历的方式实现可中断的递归</strong>。所以render的工作可以分为两部分：“递”和“归”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650103054057-67a3ac8f-a2c6-471a-b929-e502c08f3fbf.png" alt="image.png"><a name="jLTve"></a></p><h3 id="beginwork" tabindex="-1">beginWork <a class="header-anchor" href="#beginwork" aria-hidden="true">#</a></h3><p>beginWork的工作是传入当前Fiber节点，创建子Fiber节点。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650103653750-4c607ecd-c134-4d16-891f-baf4492da019.png" alt="image.png"><br>在update阶段中，会涉及diff算法，用jsx对象(VNode)与<code>current Fiber树</code>进行比对，判断DOM节点是否可以复用，比对成功就可以拷贝旧fiber节点复用，不能复用则新创建fiber节点，比对的<code>currentFiber</code> 打上<code>deletion</code>的<code>effectTag</code>，最后生成<code>workInProgress Fiber树</code>。</p><p>在mount阶段中，由于当前<code>current Fiber树</code>仅存在<code>rootFiber</code>，所以VNode在与fiber进行比对时，都是新建fiber。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650103764760-ec5eae36-6e54-4f86-b8a4-936c99ff0d52.png" alt="image.png"><br>在render的&quot;递&quot;阶段，dfs遍历fiber节点树，与旧fiber树(current fiber)进行比对，若需要对 对应的DOM进行增删改操作时，会给当前fiber节点打上标志（<strong>effectTag</strong>），在commit阶段遍历<strong>effectList链表</strong>，对DOM进行 增删改操作。<br><strong>注意：</strong> 首次渲染时(mount)，递归VNode树，创建fiber节点，并不会对每个fiber节点打上effectTag，只会对根节点<code>rootFIber</code>打上<code>palacement</code>的<code>effecTag</code>，在commit阶段，只会执行一次DOM节点插入操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650104324733-ad6baf0a-00b4-4486-ace5-d1f570844d32.png" alt="image.png"><a name="OjrWH"></a></p><h3 id="completework" tabindex="-1">completeWork <a class="header-anchor" href="#completework" aria-hidden="true">#</a></h3><p>在completeWork中，<strong>update主要处理props</strong>，不需要生成DOM节点，处于更新阶段，之前已经渲染过了，存在一颗完整的<code>currentFiber</code>树，可以直接复用DOM。对处理的props生成<code>updateQueue</code>，最终在commit阶段渲染到页面。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650104730158-9f325ee5-fc73-4d6a-a4e8-f5036b596e50.png" alt="image.png"><br>而在mount时(首次渲染)，需要根据fiber节点生成对应的DOM，挂在<code>fiber.stateNode</code>上，<strong>并将子孙的DOM节点插入上层的DOM节点中，形成一棵DOM树</strong>。形成DOM树，但不会立即插入到页面中去，这个操作是在内存中完成的，不是在浏览器中完成，需要等到commit阶段才会将其插入到页面。 同样也会处理props的逻辑。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650104834885-eb169994-7751-44f3-9651-489c8dedd98d.png" alt="image.png"><br>至此我们会生成一棵fiber树，树中存被打上标记(effectTag)的节点，同时我们还需要生成<code>**EffectList**</code>链表，链表上是<strong>所有被打上标记的节点</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650105432464-935e3f57-e02e-4cd2-892e-e96a4142845f.png" alt="image.png"><a name="n6sFb"></a></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h3><p>整个render阶段，就是<code>Reconciler</code>执行的全过程，分为“递”和“归”两个过程。<br>其中“递”阶段会执行<code>beginWork</code>，“归”阶段会执行<code>completeWork</code>。<br>render阶段会区分<code>mount</code>(首次渲染)和<code>update</code>。</p><ul><li><p>在递阶段的mount阶段，由于此时<code>currentFiber</code>树为空，其只有<code>rootFiber</code>节点，此时根据组件返回的JSX (VNode) 在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为<code>workInProgress Fiber树</code>。并对<code>rootFiber</code>打上<code>placement</code>的effectTag。</p></li><li><p>在递阶段的update阶段，<code>workInProgress fiber</code>的创建可以复用<code>current Fiber树</code>对应的节点数据，复用更新fiber节点（diff算法）。<code>fiber.alternate</code>将<code>current fiber </code>和 <code>workInProgress fiber</code>连接起来，故在<code>workInprogressFiber</code>树中可以拿得到其对应的<code>current Fiber</code>节点。 在遍历fiber节点时，会比对<code>current fiber </code>和 <code>workInProgress fiber</code>节点（同层比较），比对需要更新的节点打上<code>EffectTag</code>标志。</p></li><li><p>在归阶段的mount阶段，根据fiber节点生成对应的DOM，挂载<code>fiber.stateNode</code>上。生成子孙节点的DOM节点，并按照<strong>父子规则</strong>插入组成<code>DOM树</code>。并对props进行处理，生成<code>updateQueue</code>。此时便已经构建好了一棵<code>**离屏DOM树**</code>。</p></li><li><p>在归阶段的update阶段，不需要生成DOM节点，fiber节点已经存在了Dom节点了。这时需要处理props，生成<code>workInProgress.updateQueue</code>，最终会在<strong>commit阶段</strong>被渲染在页面上。 如果新增一个fiber节点，此时并不需要生成对应的DOM结构，只需要为其打上一个<code>effectTag</code>即可，在递阶段完成。 在往上执行归操作时，将被标记的fiber节点(effectTag) 组成一个<code>effectList链表</code>，为了在commit阶段更加高效操作DOM。</p></li></ul><p>最终，我们得到了处理过的<code>workInprogress fiber</code>树，<code>effectList</code>链表、<code>updateQueue</code>保存了变化的props数据，<code>effectList</code>和<code>updateQueue</code>被挂载在<code>workInprogress fiber</code>的属性上的。<br>然后将<code>fiberRootNode</code>被传递给<code>commitRoot</code>方法，开启<code>commit阶段</code>工作流程。<br><strong>整个render阶段都是在内存中完成。</strong></p><p><a name="b7AMj"></a></p><h2 id="_7-commit流程" tabindex="-1">7. commit流程 <a class="header-anchor" href="#_7-commit流程" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650113650443-2581ed40-8169-48ee-b55b-13cc2a1cb962.png" alt="image.png"><a name="fWqrk"></a></p><h3 id="before-mutation阶段" tabindex="-1">before mutation阶段 <a class="header-anchor" href="#before-mutation阶段" aria-hidden="true">#</a></h3><p><code>before mutation</code>阶段的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。<strong>在该阶段操作DOM，完成DOM渲染。</strong><br>commitBeforeMutationEffects整体分为如下三部分：</p><ol><li>处理<code>DOM节点</code>渲染/删除后的<code> autoFocus、blur</code> 逻辑。</li><li>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</li><li>调度<code>useEffect</code>。</li></ol><p>这里并不会对DOM进行操作，主要是完成一些调度、初始化工作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650115575186-4f6bb943-30b4-4e1e-a395-235f52da8b57.png" alt="image.png"><a name="CR5Aj"></a></p><h3 id="mutation阶段" tabindex="-1">mutation阶段 <a class="header-anchor" href="#mutation阶段" aria-hidden="true">#</a></h3><p>类似<code>before mutation</code>阶段，<code>mutation</code>阶段也是遍历<code>effectList</code>，执行函数。这里执行的是<code>commitMutationEffects</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650115966692-fd620189-ad51-42ba-8df4-cd958f68e909.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650116053816-60cf8da3-5637-4d26-92eb-a0c7d2105d73.png" alt="image.png"><br><code>Update effect</code>主要更新DOM元素，将<code>fiber.updateQueue</code>的props更新到页面的DOM中去。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650116084093-f2c14aef-b1c0-430a-96ba-cd18674137fc.png" alt="image.png"><br>在<code>Deletion effect</code>中会触发<code>componentWillUnmount</code>的生命周期钩子，这里做的主要是DOM卸载工作，执行<code>uesEffect</code>销毁函数，解绑ref。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650116183479-d026fd8e-50b7-4e08-bd2f-4fccaf8b6b3c.png" alt="image.png"><a name="fX5sE"></a></p><h3 id="layout阶段" tabindex="-1">layout阶段 <a class="header-anchor" href="#layout阶段" aria-hidden="true">#</a></h3><p>该阶段之所以称为<code>layout</code>，因为该阶段的代码都是在<strong>DOM渲染完成</strong>（mutation阶段完成）后执行的，此时可以拿到更新后的DOM。<br>该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段。</p><p>与前两个阶段类似，<code>layout阶段</code>也是遍历<code>effectList</code>，执行函数。<br>具体执行的函数是<code>commitLayoutEffects</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650116496067-2b5e73f5-ae68-4827-84e8-e387781ecaea.png" alt="image.png"><br>然后将<code>fiberRootNode</code>的<code>current</code>指向当前<code>workInprogress Fiber树</code>，它会变为<code>current Fiber树</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650116551537-55519e4d-d3ab-4936-b008-0b183623204e.png" alt="image.png"><a name="V37yp"></a></p><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-hidden="true">#</a></h3><p>整个commit分为三个阶段，<code>beforeMutaion</code>、<code>mutaion</code>、<code>layout</code>。<br>这三个阶段都要遍历<code>effectList</code>，执行相应操作，具体如下：<br><code>beforeMutaion</code>：</p><ol><li>处理DOM渲染/删除时 focus、blur等逻辑状态。</li><li>执行<code>getSnapshotBeforeUpdate</code>钩子。</li><li>调度<code>useEffect</code>，注意不是执行，将<code>flushPassiveEffects</code>添加到<code>scheduleCallbak</code>中，在layout阶段之后再执行，<code>flushPassiveEffects</code>内部会遍历<code>effectList</code>，执行所有的<code>useEffect</code>回调。</li></ol><p><code>Mutaion</code>：</p><ol><li>对DOM进行操作，增删改。</li><li><code>effectTag</code>为<code>palacement</code>代表新增节点，将fiber对应的DOM节点挂载到对应的父DOM下。</li><li><code>effectTag</code>为<code>deletion</code>代表删除节点，在删除DOM节点时，会触发<code>componentWillUnmount</code>生命周期钩子，会执行useEffect的销毁函数，解绑ref，相应删除它的子孙节点。</li><li><code>effectTag</code>为<code>update</code>代表更新节点，将fiber的<code>updateQueue</code>更新到对应DOM上去。</li><li>创建文本节点。</li></ol><p><code>Layout</code>：</p><ol><li>调用生命周期钩子、hook相关操作。 <ol><li>class组件会调用<code>componentDidMount</code>或<code>componentDidUpdate</code>钩子。</li><li>函数组件会调用<code>useLayoutEffect</code>的回调函数，调度<code>useEffect</code>的<code>销毁与回调函数</code>。执行<code>useEffect</code>的返回函数，执行更新前组件的销毁动作。</li><li>setState的第二个回调函数也会在这里调用，这里可以拿到更新后的<code>state</code>。</li></ol></li><li>获取DOM实例，更新Ref。</li><li>将<code>fiberRootNode</code>的<code>current</code>指向当前<code>workInprogress Fiber树</code>，它会变为<code>current Fiber树</code>，而之前的<code>current Fiber树</code>变为 <code>workInprogress Fiber树</code>。</li></ol><p><a name="zponV"></a></p><h2 id="_8-为啥要废弃一些生命周期" tabindex="-1">8. 为啥要废弃一些生命周期？ <a class="header-anchor" href="#_8-为啥要废弃一些生命周期" aria-hidden="true">#</a></h2><p><code>reconciler</code>在React16使用<code>fiber</code>进行了重构，**支持异步可中断的操作，**reconciler的任务可能中断/重新开始。<br>如当前render阶段被中断，下次再执行时，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650118231230-d68e396a-097a-4028-9fdf-cf0ded97b2fa.png" alt="image.png"></p><p><a name="jA7aP"></a></p><h2 id="_9-effect和uselayouteffect有啥区别" tabindex="-1">9. Effect和useLayoutEffect有啥区别？ <a class="header-anchor" href="#_9-effect和uselayouteffect有啥区别" aria-hidden="true">#</a></h2><p><a name="JdiA5"></a></p><h3 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-hidden="true">#</a></h3><p>这两个函数的使用方式其实非常简单，他们都接受一个函数一个数组，只有在数组里面的值改变的情况下才会再次执行 effect。 <a name="i5K4k"></a></p><h3 id="差异" tabindex="-1">差异 <a class="header-anchor" href="#差异" aria-hidden="true">#</a></h3><ul><li>useEffect 是异步执行的，而useLayoutEffect是同步执行的。</li><li>useEffect 的执行时机是浏览器完成渲染之后(<code>commit阶段完成后</code>)，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前(<code>commit阶段的layout阶段</code>)，和 componentDidMount 等价。</li></ul><p>如在<code>useEffect</code>和<code>useLayoutEffect</code>中<code>setState</code>，因为 useEffect 是渲染完之后异步执行的，所以会出现闪烁现象，有旧state变为新state的闪烁。<br>而 <code>useLayoutEffect</code> 是渲染之前同步执行的，所以会等它执行完再渲染上去，就避免了闪烁现象。也就是说我们最好把操作 dom 的相关操作放到 <code>useLayouteEffect</code> 中去，避免导致闪烁。</p><p><code>mutation阶段</code>会执行<code>useLayoutEffect hook</code>的销毁函数。<br>在<code>layout阶段</code>开始时，<code>useLayoutEffect hook</code>从上一次更新的销毁函数调用 到本次更新的回调函数调用是同步执行的。<br>而<code>useEffect</code>则需要先在<code>beforeMutaion阶段</code>调度，推入<code>SchduleCallbak</code>中，然后在commit阶段完后异步执行。<br>在<code>Layout阶段完成后</code>再异步执行，在dom渲染挂载完成后异步执行。<br>我们习惯在<code>useEffect</code>中执行一些副作用，<strong>因此它不应该阻塞浏览器的渲染。</strong><a name="N8UpK"></a></p><h3 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-hidden="true">#</a></h3><ol><li>优先使用 useEffect，因为它是异步执行的，不会阻塞渲染</li><li>会影响到渲染的操作尽量放到 useLayoutEffect中去，避免出现闪烁问题</li></ol><p><a name="AcYP3"></a></p><h2 id="_10-diff" tabindex="-1">10. diff <a class="header-anchor" href="#_10-diff" aria-hidden="true">#</a></h2><p>react的diff发生在<code>reconciler</code>的<code>beginwork</code>中，只有在update时才会涉及diff算法。<br>diff算法是<code>VNode/JSX对象</code>和<code>current fiber</code>进行比较，比较它们的DOM，决定新建或复用fiber节点。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650160800678-653546e6-50ba-42db-a3aa-07763e39f663.png" alt="image.png"><br>diff分为<strong>单节点diff</strong>和<strong>多节点diff</strong></p><p><a name="gDTrs"></a></p><h3 id="单节点diff" tabindex="-1">单节点diff <a class="header-anchor" href="#单节点diff" aria-hidden="true">#</a></h3><p>只有key和type都相同时，才认为DOM节点可以复用，DOM节点是挂在<code>fiber.stateNode</code>上，故fiber节点也直接拷贝副本复用即可。<br>当本次更新的JSX对象<strong>只有一个节点时</strong>，会触发单节点diff。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650160986230-2a04a65a-8177-4c80-8c09-8575e429457a.png" alt="image.png"><a name="rkwbw"></a></p><h3 id="多节点diff" tabindex="-1">多节点diff <a class="header-anchor" href="#多节点diff" aria-hidden="true">#</a></h3><p>若本次更次的VNode的children是一个数组，就是多节点diff。<code>VNode</code>是一个数组，<code>currentFiber</code>是一个链表，数组和链表进行比较，所以不能双指针头尾比较，只能通过<strong>指针遍历链表、遍历数组进行比较</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650161548221-7da674ee-8253-4662-a0d5-41ea92505432.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650161625377-0f363ec3-2e65-425b-a2a8-ae783c192da4.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650161683967-b736a911-d2cc-42f9-8ba2-859853fbda01.png" alt="image.png"><br>当<code>newChildren</code>和<code>oldFiber</code>都未遍历完，则从根据key来找节点，决定是否复用。为了优化查找，所以在这里会存储一个map结构，为了快速找到key对应的<code>oldFiber</code>。 <br>然后直接遍历<code>newChildren</code>数组，在map中找key，找到相同key，再比较type是否相同来决定是否复用DOM，若相同直接复用fiber副本，将这个key从map中删除。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650161720924-4d4aa8f2-daf2-444b-b566-b132b0b11486.png" alt="image.png"></p><p><a name="iUWot"></a></p><h3 id="vue的diff和react的diff有啥异同" tabindex="-1">vue的diff和react的diff有啥异同？ <a class="header-anchor" href="#vue的diff和react的diff有啥异同" aria-hidden="true">#</a></h3><p><strong>相同点：</strong></p><ul><li>出发点相同，在update时，与上一次<code>VNode/CurrentFIber</code> 进行比对，来决定DOM是否可以复用，<strong>减少DOM操作次数，提高性能。</strong></li><li>都是通过比对** key和type**，来决定两个DOM是否相同复用。</li><li>单节点diff相同</li><li>多节点diff时，暴力比对的策略相同，通过map来进行优化，更快找到key对应的<code>oldFiber/VNode</code>。</li><li>都是同层级之间diff。</li></ul><p><strong>不同点：</strong></p><ul><li>vue的diff发生在patch阶段，diff后，直接就操作<code>新建/更新DOM</code>了，是同步的过程。react的diff发生在<code>reconciler</code>中，它不会立即更新DOM，而是复用/新建fiber节点，若需要操作DOM，则对对应fiber节点打上<code>effectTag</code>的标志，<strong>在commit阶段(renderer)中</strong>，遍历<code>effectList</code><strong>批量操作更新DOM。</strong></li><li>react的diff是可以被打断终止的，当预留时间不够/有高优先级任务进来，再次恢复时，可以从之前的中间态继续执行。</li><li>diff比较的对象不同，vue中是比较前后两次<code>VNode数组</code>，react是<code>VNode数组</code>和<code>currentFiber链表</code>比对。</li><li>多节点diff实现有所不同，在vue中是比较的是两个数组，所以采用了**头尾双指针(**头头、头尾、尾尾、尾头)比较。 而react是链表和数组比较，只能从头遍历比较，从左向右比较， <strong>vue的更加高效。</strong></li></ul><p><a name="uHfUD"></a></p><h2 id="_11-状态更新机制" tabindex="-1">11. 状态更新机制 <a class="header-anchor" href="#_11-状态更新机制" aria-hidden="true">#</a></h2><p><a name="rTqGX"></a></p><h3 id="更新流程" tabindex="-1">更新流程 <a class="header-anchor" href="#更新流程" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650179954597-75df9dc6-fb08-4bc1-a4a4-83437e5373a1.png" alt="image.png"></p><p><strong>在react中，需要我们手动触发状态更新，react并不会感知状态是否更新。</strong><br>总共有如下这几种触发状态更新的方法，调用触发状态更新方法会生成<code>update对象</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650180022181-5e389253-bf14-4a28-a414-3839f053e7fa.png" alt="image.png"><br>在render阶段，是从<code>rootFiber</code>向下遍历比对生成<code>workInProgress Fiber</code>的，从当前<strong>触发更新的fiber</strong>向上遍历可以找到<code>rootFiber</code>。<br>而在<code>当前触发更新fiber中</code>，可以从下向上遍历找到<code>rootFiber</code>。在render阶段，会从向下遍历(dfs)，找到对应的<code>更新fiber</code>，计算<code>state</code>、打上<code>effectTag</code>标签等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650180108958-3938de04-965d-4b23-b2a7-623a77481377.png" alt="image.png"><br>此时已经拿到<code>rootFiber</code>，而且已知该<code>Fiber树</code>中必然有某个<code>FIber节点</code>包含<code>Update对象</code>，需要进行更新。此时，需要<code>Scheduler</code>根据<strong>更新优先级</strong>来决定 是异步更新还是同步更新。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650180284450-ec01bb57-fbf0-48a5-a84f-95045ca29bb2.png" alt="image.png"></p><p><a name="XWCIG"></a></p><h3 id="update对象" tabindex="-1">update对象 <a class="header-anchor" href="#update对象" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650182754476-6a479e8a-f0b1-4652-9bbd-5f1269c28a64.png" alt="image.png"><br>更新是由具体<code>Fiber节点</code>上触发的，更新会产生Update对象，一个<code>Fiber节点</code>可能会产生多个<code>Update对象</code>，如连续触发多次<code>setState</code>。<br>多个<code>Update对象</code>通过<code>next指针</code>连接成一个链表，存储在<code>fiber.updateQueue</code>中。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650182791000-bc3b0c45-baaa-4fe2-8da3-fc31b0ca01f5.png" alt="image.png"><a name="tiMwQ"></a></p><h3 id="updatequeue结构" tabindex="-1">updateQueue结构 <a class="header-anchor" href="#updatequeue结构" aria-hidden="true">#</a></h3><p>更新调度进入render阶段后，会将<code>shared.pending</code>的环 剪开并链接在<code>updateQueue.lastBaseUpdate</code>后面，将<code>本次更新的Update</code>取出链接在<code>lastBaseUpdate</code>后面。</p><p>这样会形成一个<code>updateQueue.baseUpdate链表</code>，接下来遍历链表，基于<code>baseState</code>(上一次的state)，依次与遍历到的<code>Update</code>进行计算产生<code>新的state</code>，当遍历完毕最后一次计算得到的<code>state</code>就是本次<code>该Fiber节点</code>在本次更新的state（源码中叫做<code>memoizedState</code>）。 然后再给这个fiber节点打上<code>effectTag</code>，在<code>commit阶段</code>渲染到页面中去。</p><p>由于在遍历<code>baseUpdate链表</code>时，每个<code>Update</code>都与<code>baseState</code>进行计算，<code>baseState</code>只有在<code>commit阶段</code>执行完毕才会变化，故调用多次<code>setState</code>并没有基于上次setState更新的state而进行更新，只有最后一次<code>setState</code>生效，一种<code>批量更新的机制</code>。</p><p>如果要基于上次更新的state而进行计算，需要使用在setState中使用函数式写法。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650183074089-a9323e02-14d0-44d4-adfc-faaf018a2655.png" alt="image.png"><a name="URSMJ"></a></p><h3 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-hidden="true">#</a></h3><p>在<code>reconciler</code>中任务的执行是可以被打断的，当有高优先级任务，<code>reconciler</code>中的任务被打断，转而执行高优先级任务，执行完毕可以回到打断的任务中，基于中间态接着执行。<br>通过<strong>优先级</strong>可以决定哪个<code>更新任务</code>优先被执行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650184841629-2aad87fe-cb50-4d6d-a739-c8bb5c2bfbd9.png" alt="image.png"><br>优先级调度需要开启<code>comcurrent</code>模式，React18已经默认切换为<code>comcurrent</code>模式了。开启了这个模式，就可以调度任务的优先级，高优的<code>update</code>先执行。<br>通过如下<code>createRoot</code>创建入口函数，就可以开启<code>comcurrent</code>模式了。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> rootElement </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> root </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createRoot</span><span style="color:#A6ACCD;">(rootElement)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">root</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;">/&gt;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>使用<code>ReactDOM.render()</code>创建入口函数，它属于<code>legacy</code>模式，这是当前<code>React17</code>使用的方式，它不支持优先级调度，不支持<code>任务中断/优先级</code>。<br>所以要想高性能完成更新渲染，需要开启<code>concurrent</code>模式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650186041877-e58bcc90-e2b3-4f06-8fa6-04e62ceeeb2b.png" alt="image.png"><br>B2被跳过了，那么第二次render时，它的<code>baseState</code>为跳过的前一个<code>update</code>计算的<code>State值</code>，并不是前一次render生成的<code>memoizeState</code>。</p><p><strong>保证任务中断/恢复时Update对象不丢失</strong><br>本次更新的<code>Update对象</code>会存储在<code>updateQueue.shared.pending</code>，以一个<code>单向环状链表</code>形式保存。由于fiber使用<code>双缓存机制</code>技术，所以该<code>update对象</code>也同样保存在了<code>currentFiber.updateQueue</code>中。<br>当render被中断重新执行后，会基于<code>currentFiber.updateQueue</code>克隆出<code>workInprogressFiber.updateQueue</code>。<br>当<code>commit阶段</code>完成渲染，由于<code>workInProgress updateQueue.lastBaseUpdate</code>中保存了<code>上一次的Update</code>，所以<code> workInProgress Fiber树</code>变成<code>current Fiber树</code>后也不会造成Update丢失。</p><p><strong>保证连续状态的依赖性</strong><br>在<code>setState</code>中使用函数更新state，那么每次拿到的state 是基于上次更新得到的，这样更新状态是具有连续性的。<br>在优先级调度下，有多个连续的<code>Update</code>，且前后具有依赖性的。那么当跳过某个<code>update</code>时，保存在<code>baseUpdate</code>中的不仅是该<code>Update</code>，还包括链表中该Update之后的<code>所有Update</code>。</p><p>故因为如上机制，所以在<strong>开启优先级调度模式</strong>下，可能会造成<code>update</code>被重复多次执行，其生命周期也会被多次执行，所以在React16.4废弃了一些生命周期（componentWillxxxx），这些生命周期是在<code>render阶段</code>触发的。</p><p><a name="L0ogu"></a></p><h2 id="_12-setstate是同步还是异步" tabindex="-1">12. setState是同步还是异步？ <a class="header-anchor" href="#_12-setstate是同步还是异步" aria-hidden="true">#</a></h2><p><a href="https://zhuanlan.zhihu.com/p/350332132" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/350332132</a><br><strong>结论：</strong><br>只要你进入了 react 的调度流程，那就是异步的。只要你没有进入 react 的调度流程，那就是同步的。<br>在<code>setTimeout</code>、<code>setInterval</code> ，直接在 DOM 上绑定原生事件等。这些都不会走 React 的调度流程，在这种情况下调用 setState ，那这次 setState 就是同步的。</p><p><strong>异步情况：</strong><br>在生命周期中、合成事件中，进入这些回调函数之前，<code>isBatchingUpdates</code>会置为<code>true</code>，触发了 react 的<strong>批处理机制</strong><code>batchedUpdates</code>，将多次<code>setState</code>放到队列中，在<code>reconciler</code>中异步批量执行，最终只会执行最后一次<code>setState</code>。 故在setState后拿不到更新后的状态值。 当同步代码执行完毕后，<code>isBatchingUpdates</code>会被置为false。</p><p><strong>同步情况：</strong><br>在异步代码、原生事件中 调用setState不会触发批量更新机制，可以在setState后立即拿到更新的state。在同步代码执行完毕后，异步代码才会执行，此时<code>isBatchingUpdates</code>为<code>false</code>，故不会进入react调度流程，不会异批量更新，所以可以立即拿到更新后state。</p><p>**注意：**在函数组件中，无论怎么setState都拿不到更新后的值，这是由于函数闭包引起的，重新执行了函数。</p><p>react的主张<strong>状态不可变</strong>，所以拿到立即拿到更新后的state这个操作是不合理的，要么就将其状态提到最上层。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650209399196-45e9e1ae-1e13-4a87-aca4-d36e493fc95a.png" alt="image.png"></p><p><a name="YiWSa"></a></p><h2 id="_13-为啥推荐用函数组件、hook" tabindex="-1">13.为啥推荐用函数组件、hook？ <a class="header-anchor" href="#_13-为啥推荐用函数组件、hook" aria-hidden="true">#</a></h2><p><a name="u1TuY"></a></p><h3 id="原class组件的痛点" tabindex="-1">原class组件的痛点： <a class="header-anchor" href="#原class组件的痛点" aria-hidden="true">#</a></h3><ul><li>在组件之间复用状态逻辑很难，使用renderProps、HOC，这些都有缺点，会让代码变得难以理解，而且会造成回调地狱，代码难以维护。</li><li>复杂组件变得难以理解，我们经常会在生命周期中做一些<strong>副作用操作</strong>，可能在一个生命周期中，有多个互不相干的逻辑，这样且不好进行拆分，容易导致BUG。</li><li>class组件的this难以理解，还需要给事件处理函数绑定this。</li><li>性能问题，calss相较于function不是很好压缩。而且class组件对<code>concurrent(同步)模式</code>支持不友好。在<code>render阶段</code>若有高优先级的任务，会中断当前任务，转而执行高优先级的任务，执行完毕后可以回到中断的任务接着<code>中间态</code>继续执行。class组件的实例对象是共享的，在某个任务中修改了state，其他任务可以感知到，这样会造成问题。</li></ul><p><a name="ZkjWF"></a></p><h3 id="函数组件-hook-带来的优点" tabindex="-1">函数组件(hook)带来的优点： <a class="header-anchor" href="#函数组件-hook-带来的优点" aria-hidden="true">#</a></h3><ul><li>函数组件可以使用hook来更加优雅的逻辑复用，提高代码的维护性。</li><li>函数组件使用hooks(useEffect)来替代生命周期，可以在hook中写副作用操作，可以将不同的副作用操作抽离到不同的hook中。<strong>利用hook提供的副作用的API，使得生命周期变成了一个“底层概念”</strong>，无需开发者考虑。开发者工作在更高的抽象层次上了，<strong>从过去的命令式编程转变成了声明式编程。</strong></li><li>函数组件可以更好的支持<code>concurrent模式</code>，并发渲染**“多个版本”的组件树**，这些组件树是多个独立的函数，故它们的状态也互相不影响。</li></ul><p><strong>函数组件的心智模型</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650211859168-fd596413-41d4-4165-8862-8731457eee2d.png" alt="image.png"><br>函数组件采用函数式编程，需要<strong>保持函数组件是一个纯函数</strong>，它的state、ref都由hook提供。函数式组件仅仅是**【外部数据=&gt;view】的映射**，属于pure function的心智模型。</p><p><a name="qOkP0"></a></p><h2 id="_14-实现usestate" tabindex="-1">14.实现useState <a class="header-anchor" href="#_14-实现usestate" aria-hidden="true">#</a></h2><p>实现分为两步：</p><ol><li>通过一些途径触发更新，组件重新render(函数组件重新执行)。</li><li>使用useState可以拿到最新的值。</li></ol><p><strong>思路：</strong></p><ol><li>useState这个hook存储在组件对应的<code>fiber节点</code>上，一个组件有多个hook，会连成链表存储。每次调用useState，就会产生一个hook。</li><li>调用useState的触发更新方法，会产生一个update，存储在hook.queue.pending中，多个update会组成单向环状链表</li><li>在mount时，会创建hook并添加在fiber上；当通过某个hook的触发更新函数 触发更新，会往对应hook.queue.pending上添加上update。组件重新render，函数组件里的代码从上到下依次执行，执行<code>useState</code>时会判断是否有update，然后计算状态。</li><li>一个组件会有多个hook，多个hook链接成链表，是通过维护一个<strong>指针变量</strong><code>workInProgressHook</code> 来确定是当前useState的hook 是哪一个hook。每次触发调度时，都会将当前hook指针变量置为第一个hook，触发组件render，重新执行useState，每执行完一个useState，<code>workInProgressHook</code>指针后移一位，这样就可以确定当前useState对应的是哪个hook了。</li><li>这里简单写法，直接就在<code>rootFiber</code>上，省略了从当前<code>fiber</code>节点向上查找<code>rootFiber</code>的过程。在<code>render阶段</code>会收到<code>Scheduler</code>发来的任务，遍历<code>rootFiber</code>找到对应的fiber节点，遍历<code>updateQueue</code>计算state。</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// 通过workInProgressHook变量始终指向当前正在工作的hook。</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> workInProgressHook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 判断时mount or update</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> isMount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// hook存放在对应的fiber节点上,一个组件会有多个hook,故这里存放为hook链表</span></span>
<span class="line"><span style="color:#676E95;">// 产生状态更新时，会生成update结构，多个update组成单向环状链表，在class组件中update存放在updateQueue中，在函数组件中存放在hook中</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fiber </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 存放hook链表</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">memoizedState</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">stateNode</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> App</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 模拟调度Scheduler</span></span>
<span class="line"><span style="color:#676E95;">// 在shcdule里会调用函数组件，进入render阶段</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">schedule</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 更新前将workInProgressHook重置为fiber保存的第一个Hook</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 执行函数组件,触发组件render</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">app</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stateNode</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 置为update阶段</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">isMount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 调用更新state的方法内部实际调用dispatchAction</span></span>
<span class="line"><span style="color:#676E95;">// queue === fiber.hook.queue === fiber.updateQueue(class组件中)</span></span>
<span class="line"><span style="color:#676E95;">// action 更新state的函数</span></span>
<span class="line"><span style="color:#676E95;">// 作用：更新state时会调用，创建update对象，添加在fiber.hook.queue.pending上,组成单向环状链表,并触发schedule进行调度</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">dispatchAction</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">update</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    next</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// queue.pending不存在update</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 多个update会构成单向环状链表，这里仅有一个update，也要与自己构成环状链表</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">update</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">update</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// queue.pending上已存在环状链表,此次新加入的update要插入到环状链表的最后</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// queue.pending指向环状链表的最后一个节点,queue.pending.next则指向第一个节点</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 要将此次update插入环状链表,且作为最后一会节点</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 1. 先将自己的next指针指向第一个节点  2. 再让最后一个节点的next指针指向自己</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">update</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">update</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// update存放在 fiber.memorizeState(hook).queue.pending上</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// queue.pending指向update链表的最后一个节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">update</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 此时已经生成了update对象,放到了fiber节点的hook.queue.pending上了,此时需要触发schedule调度机制,后续render</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">schedule</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 当调用更新state的方法时,会触发函数重新执行,故useState也会再次执行,此时isMount为false,update阶段</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">initialState</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// useState生成hook</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">isMount</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">hook</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      queue</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        pending</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;">// 存放state</span></span>
<span class="line"><span style="color:#F07178;">      memoizedState</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialState</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      next</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#676E95;">// 指向下一个hook</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 判断fiber上是否存在hook</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;">// 将当前hook链接到已有的hook之后,引用数据，同时会更新到fiber.memorizeState中</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 指向当前hook,即hook链表最后一个hook</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// update阶段</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">hook</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 指向下一个hook</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workInProgressHook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 当前hook的state</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">baseState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 这里已经进入了render阶段,遍历updateQueue,计算state</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">firstUpdate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 执行多个update,这里不考虑优先级调度相关</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">do</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;">// 计算state</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">firstUpdate</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">baseState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">action</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">baseState</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;">// 指针后移</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">firstUpdate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">firstUpdate</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">next</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">firstUpdate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;">// 最后一个update执行完后跳出循环</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// update执行完后,清空queue.pending</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pending</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 更新hook上的state</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">baseState</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 调用useState返回state和更新state的方法,在useState中</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 通过调用dispatchAction来生成update对象, hook.queue === updateQueue</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 当触发更新后,这里返回更新后的state</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 这里通过函数克里化,让每个方法默认带其hook.queue</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">baseState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dispatchAction</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bind</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hook</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">queue</span><span style="color:#F07178;">)]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// 模拟组件</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">updateNum</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">flag</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setFlag</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">`${</span><span style="color:#A6ACCD;">isMount </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">mount</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">update</span><span style="color:#89DDFF;">&quot;}</span><span style="color:#C3E88D;"> num: </span><span style="color:#89DDFF;">`</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">flag</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    click</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">updateNum</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">    set</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setFlag</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">flag</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">flag</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">schedule</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;">// 触发更新</span></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">click</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p><a name="aGPdU"></a></p><h3 id="hook数据结构" tabindex="-1">hook数据结构 <a class="header-anchor" href="#hook数据结构" aria-hidden="true">#</a></h3><p>一个组件会有多个hook，组成链表存储在fiber.memoizeState中，通过<code>workInprogressHook</code>来确定当前hook。<br><code>hook.queue </code>等同于<code> updateQueue</code>，它存储<code>update对象</code>，<code>pending</code>始终指向<code>update</code>链表的最后一个节点。<br>不同的<code>hook.memoizeState</code>保存不同的值，useEffect、useRef、useState保存的都不同。 <br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650259862832-1546889a-5591-4f97-9f22-db42a2b5fd4a.png" alt="image.png"><a name="awFby"></a><a name="b48W1"></a><a name="g0PmV"></a></p><h2 id="_15-为什么hook需要放在顶层" tabindex="-1">15.为什么hook需要放在顶层？ <a class="header-anchor" href="#_15-为什么hook需要放在顶层" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650247685462-5a5621f4-15d6-471b-956e-2a6c438dbd55.png" alt="image.png"><br>组件的hook是被存放在对应的fiber节点中，多个hook组成一个链表，只要每次render时(重新执行)，hook的顺序都不变，那么就能确认当前执行<code>useState</code>、<code>useEffect</code>是哪一个hook。</p><p>通过一个指针变量<code>workInProgressHook</code>来指向当前hook，在render时，将其指向fiber上hook链表第一个节点，在执行组件里的代码时，每次执行<code>useState</code>、<code>useEffect</code>会将指针后移一位，指向下一个hook，这样就能确定当前是哪一个hook了。</p><p>所以一定要保证每次render(函数组件执行时)调用hook的顺序，这样才能在调用hook时确定当前是哪个hook，然后可以获取当前hook中保存的数据。 <strong>若放在if、循环里 则不能保证 一定是按相同顺序被调用，这样会出现BUG。</strong></p><p><a name="fTUXG"></a></p><h2 id="_16-useref" tabindex="-1">16.useRef <a class="header-anchor" href="#_16-useref" aria-hidden="true">#</a></h2><p>我们知道hook存放在对应的<code>fiber节点</code>上的，useEffect这个hook也存放在fiber节点上，它有一个结构<code>effect</code>，类似与stateHook的<code>update</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650254385249-740af9f5-b707-42c4-ba40-a775cff742b4.png" alt="image.png">useRef的实现很简单，将ref的值存储在<code>fiber.hook.memoized</code>就行。正是因为它的ref上存储的，当前组件的所有组件树都对应这一个red，故我们将ref当作<code>class组件中的this</code>来用，可以在更新ref的值后，立即获取更新后的值，不会有state的闭包问题。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650257869718-013611ee-342f-41cf-959a-5aa5f18e89a0.png" alt="image.png"><a name="N43sS"></a></p><h3 id="ref工作流程" tabindex="-1">ref工作流程 <a class="header-anchor" href="#ref工作流程" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650258303904-c42f3fd2-a190-4819-8e09-f1f86864a252.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650258328396-8aa6adc0-666f-4c3c-8d69-e9cc1bba8f26.png" alt="image.png"><br>commit阶段中，在<code>mutaion阶段</code>，根据<code>effectTag</code>对ref进行相应操作，在<code>layout阶段</code>，为ref赋值。</p><p><a name="qp9p6"></a></p><h2 id="_17-usememo、usecallback" tabindex="-1">17.useMemo、useCallback <a class="header-anchor" href="#_17-usememo、usecallback" aria-hidden="true">#</a></h2><p>这两个hook其实和useRef差不多，就是将其存储在fiber节点上，<strong>无论组件怎么渲染，产生多少个渲染树，fiber上存储的数据在多个渲染树依然是共享唯一的。</strong><br>组件重新渲染时，<strong>从</strong><code>**fiber.hook**</code><strong>上取保存的函数或计算的值</strong>，组件内不会执行计算逻辑、函数初始化，这样可以性能优化，但是存储在fiber上也是有性能消耗的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650258852889-d1c15e51-a1e1-4209-b395-d63eb617fbab.png" alt="image.png"></p><p><a name="gyvPl"></a></p><h2 id="_18-事件机制" tabindex="-1">18. 事件机制 <a class="header-anchor" href="#_18-事件机制" aria-hidden="true">#</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">handleClick</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bind</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">this</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">点我</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>React并不是将click事件绑定到了div的真实DOM上，而是在<code>document</code>处监听了所有的事件，当事件发生并且冒泡到document处的时候，<strong>React将事件内容封装并交由真正的处理函数运行</strong>。这样的方式不仅仅<strong>减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</strong></p><p>冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1611890469312-7504e85d-c6db-481e-b9d3-5307a3de708c.jpeg#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=url&amp;id=sw8TS&amp;margin=%5Bobject%20Object%5D&amp;originHeight=395&amp;originWidth=878&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>实现合成事件的目的如下：</p><ul><li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了<strong>跨平台开发</strong>的能力，不强依赖浏览器DOM；</li><li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，**有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，**事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li></ul><p>事件池机制意味着** SyntheticEvent对象会被缓存且反复使用**，目的是提高性能，减少创建不必要的对象。当SyntheticEvent对象被收回到事件池中时，属性会被抹除、重置为null。<br><strong>但是React17之后不将SyntheticEvent对象放到事件池中统一管理了。</strong></p><p><a name="pSfpp"></a></p><h3 id="react的事件和普通的html事件有什么不同" tabindex="-1">React的事件和普通的HTML事件有什么不同？ <a class="header-anchor" href="#react的事件和普通的html事件有什么不同" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650263219741-4100e905-f6c5-4813-b091-af7139a353cb.png" alt="image.png"></p><p><a name="OJKZr"></a></p><h2 id="_19-hoc、renderprops、hooks" tabindex="-1">19. HOC、RenderProps、Hooks <a class="header-anchor" href="#_19-hoc、renderprops、hooks" aria-hidden="true">#</a></h2><p>HOC / Render Props / Hooks 三种写法都可以<strong>提高代码的复用性</strong>。但实现方法不同。<br><strong>HOC</strong><br>HOC 是对传入的组件进行增强（组合）后，返回新的组件给开发者，通过函数接受一个组件，再返回一个容器组件，容器组件的render内容就是传入的组件，可以对该组件进行组合增强其复用性。<br><strong>缺点：可读性差，易用性差</strong>，看不到接收和返回的结构，增加调试和修复问题的成本，难以理解。</p><p><strong>RenderProps</strong><br>Render Props 是指将一个返回 React 组件的函数，作为 prop 传给另一个 组件的共享代码的技术，将渲染内容由调用者来约束。主要解决组件逻辑相同而渲染规则不同的复用问题。<br><strong>缺点：<strong>代码相对冗长，但能清晰看到组件接收的 props 以及传递的功能等，可以对 props 属性重命名，不会有命名冲突。但难以在 render 函数外使用数据源，且</strong>容易形成嵌套地狱</strong>。</p><p><strong>Hooks</strong><br>上述两种都是class组件用来复用代码的方法，它们都有缺点。React Hooks 是 React 16.8 引入的一组 API，可以完成<strong>逻辑复用</strong>。使用 Hooks 时，能清晰看到组件接收的 props 以及传递的功能等，可以对 props 属性重命名，不会有命名冲突，不存在嵌套地狱，且没有数据源获取及使用范围的限制。</p><p><strong>总结∶</strong><br>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p><p><a name="i9as3"></a></p><h2 id="_20-进程、线程、协程、纤程" tabindex="-1">20.进程、线程、协程、纤程 <a class="header-anchor" href="#_20-进程、线程、协程、纤程" aria-hidden="true">#</a></h2><p><strong>进程</strong><br>通俗理解一个运行起来的程序或者软件叫做进程，每次启动一个进程都需要向操作系统索要运行资源，让进程中的线程去执行对应的代码，<strong>进程是操作系统分配资源的基本单位</strong>。</p><p><strong>线程</strong><br>线程是依赖于进程的，也称为「微进程」。它是<strong>程序执行过程中的最小单元</strong> 。<br><strong>线程是cpu调度的基本单位</strong>， 通过线程去执行进程中代码， 线程是执行代码的分支。<strong>同一个进程的多个线程共享进程的资源</strong>（省去了资源调度现场保护的很多工作）。当进程销毁后，进程下面的线程同样会被销毁。</p><p><strong>协程</strong><br>协程，又称微线程，纤程。<strong>是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』</strong>，它不受内核CPU的控制。<br>一句话说明什么是协程：<strong>协程是一种用户态的轻量级线程。</strong></p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650039600506-3bb99d21-a732-4360-ab98-adbaa6990470.png" alt="image.png"><br><strong>总结一下协程就是程序员自己定义的，在执行一个程序时可以进行中断，将线程的执行权交出去，等过一段时间后，可以回到原程序时，又可以接着前面的状态继续执行。</strong><br>在js中，<code>generator</code>就是协程的实现，执行函数时，可以中断执行，将执行权交出去，下次可以接着上次的状态接着执行函数。<br><strong>纤程和协程是一个概念，微软引入windows的不同叫法而已。协程是一种异步任务的解决方案。</strong></p><p><a name="qL9JL"></a></p><h2 id="_21-vue和react的区别" tabindex="-1">21.vue和react的区别 <a class="header-anchor" href="#_21-vue和react的区别" aria-hidden="true">#</a></h2><p><strong>1、监听数据变化的实现原理不同</strong></p><ul><li>Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。利用响应式，当修改状态后，会自动进行更新。</li><li>React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。需要自己手动<code>setState</code>告知产生状态变化。</li></ul><p>这是因为Vue和React设计理念上的区别，<strong>Vue使用的是可变数据，而React更强调数据的不可变。</strong></p><p><strong>2、模板语法的不同</strong></p><ul><li>Vue ⼀般使⽤的 HTML 的拓展模板语法，⼀般判断和循环，只能通过**指令(v-if)**来完成。</li><li>React 使⽤的则是 JSX 语法，JSX 语法可以使⽤ JS 的常⻅语法，条件、循环。使⽤的更 加原⽣。</li></ul><p><strong>3、diff不同</strong><br>在diff那节总结过了。</p><p>4、更新粒度不同，vue可以精确到组件，而React是自顶向下递归进行更新的，组件树中每个组件都会重新render。</p><p>也可以从react函数组件的优点展开来讲，vue属于面向对象编程。</p><p><a name="zzSy2"></a></p><h2 id="_22-renderprops究竟解决了什么样的问题" tabindex="-1">22. renderProps究竟解决了什么样的问题？ <a class="header-anchor" href="#_22-renderprops究竟解决了什么样的问题" aria-hidden="true">#</a></h2><p>目前我有一个场景，如下：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// App.tsx</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;">&gt;&lt;</span><span style="color:#FFCB6B;">MenuItem</span><span style="color:#89DDFF;">/&gt;&lt;/</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// Menu.tsx</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Menu </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 我如何在当前组件中传参给props.children呢？</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>解法1: renderProps</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// App.tsx</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">render</span><span style="color:#89DDFF;"> = {(</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">MenuItem</span><span style="color:#89DDFF;"> {...</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">} /&gt;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;&lt;/</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// Menu.tsx</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Menu </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// MenuItem.tsx</span></span>
<span class="line"><span style="color:#676E95;">// 在当前组件中可以通过props拿到父组件传来的值</span></span>
<span class="line"></span></code></pre></div><p><strong>如何用语言表达出他的场景？</strong><br><code>render prop</code>是一个用于告知<code>内部组件</code>需要渲染什么内容的函数prop，由外部组件定义渲染结构，而内部组件提供具体的依赖数据。类似于<code>Vue</code>里的<code>作用域插槽</code>。</p><p><strong>解法2:</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// App.tsx</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">MenuItem</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">MenuItem</span><span style="color:#89DDFF;">}&gt;&lt;/</span><span style="color:#FFCB6B;">Menu</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// Menu.tsx</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Menu </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">MenuItem</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">MenuItem</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">count</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">// MenuItem.tsx</span></span>
<span class="line"><span style="color:#676E95;">// 在当前组件中可以通过props拿到父组件传来的值</span></span>
<span class="line"></span></code></pre></div><p>其实<code>&lt;MenuItem/&gt;</code>这样写，在内部会执行这个组件，就是执行该函数。那么<code>props.children</code>其实拿到的是组件执行的返回结果<code>VNode/element/jsx对象</code>。<br>其实放在组件标签之间的内容，相当于将它原封不动的添加为 props.children属性。那么其实我可以随意的往这里嵌入内容。<br>而<code>{MenuItem}</code>这样实际上就是一个函数组件了，它相较于<code>&lt;MenuItem&gt;</code>是没有执行。</p><p>还可以利用<code>React.Children</code>这个顶层API来操作<code>props.children</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650469049244-466b2500-9388-468f-ab67-1e6fc5484532.png" alt="image.png"></p><p><a name="bL8Xv"></a></p><h2 id="_23-为什么vue不引入fiber" tabindex="-1">23. 为什么Vue不引入fiber？ <a class="header-anchor" href="#_23-为什么vue不引入fiber" aria-hidden="true">#</a></h2><p>Vue其实跟React16之前是一样的，它render - commit(patch)是一个同步的过程，同步操作DOM，<strong>为什么Vue不存在React丢帧的性能问题？如果存在为什么引入fiber来解决这个问题？</strong></p><p>其实回答这个问题，要从vue和react响应式的原理来看：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650702508840-a0ed51ac-7cae-4368-8481-d8d274033195.png" alt="image.png"><br>**Vue由于每个组件对应一个监视器，对依赖收集和派发更新，又得益于Vue的模版语法，可以实现静态编译，能准确的完成依赖收集。**这是react中动态的jsx不能做到的。<br><a href="https://juejin.cn/post/7077545184807878692" target="_blank" rel="noreferrer">https://juejin.cn/post/7077545184807878692</a></p><p><a name="UNWL8"></a></p><h2 id="_24-react为啥不实现vue那套响应式" tabindex="-1">24.React为啥不实现Vue那套响应式？ <a class="header-anchor" href="#_24-react为啥不实现vue那套响应式" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650703120671-7d071ced-dc0f-4db4-9788-2f00f38ab4e4.png" alt="image.png"><br>在React中遵循<code>状态不可变思想</code>，每次setState并没有改变原来的状态，而是使用新的空间创建新的state，所以状态压根不会被修改，因此也完成不了状态的收集。</p><p><a name="GjnRm"></a></p><h2 id="_25-为啥vue的diff能够精确到具体组件级别" tabindex="-1">25. 为啥Vue的diff能够精确到具体组件级别？ <a class="header-anchor" href="#_25-为啥vue的diff能够精确到具体组件级别" aria-hidden="true">#</a></h2><p><strong>每个组件都有对应的渲染Watcher</strong>，当状态修改时，会派发对应组件的<code>渲染Watcher</code>进行更新。<br>只要传递给子组件的props没有变化 且 没有子组件插槽，则父组件更新是不会触发子组件的更新。<br>props原理可知，子组件会对接收到的props进行观测，所以当props发生了变化(Vue内部做得)，则会触发子组件更新。<br>而当父组件中使用了子组件插槽传递内容，那么父组件更新时，会执行子组件的<code>forceUpdate</code>方法，触发子组件的更新。<br><a href="https://juejin.cn/post/6844904113432444942" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904113432444942</a></p><p><a name="jR2XY"></a></p><h2 id="_26-react组件状态不可变如何理解" tabindex="-1">26. react组件状态不可变如何理解？ <a class="header-anchor" href="#_26-react组件状态不可变如何理解" aria-hidden="true">#</a></h2><p>react的核心设计理念就是<strong>状态不可变</strong>，组件是就UI和逻辑的单元，<strong>组件视图是由状态驱动更新的</strong>。<br><strong>react的理念是同样的状态，渲染出来的视图是一样的，这也就是纯函数的概念，做到状态和UI视图的统一。</strong></p><p><strong>状态不可变的好处：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650714145920-4df726e5-93a4-4bff-80f9-2be693a7827a.png" alt="image.png"><br>总结下就是，状态可变可能会引起状态的流向不确定，使用不可变状态更加方便追踪数据的变化，使组件逻辑变得简单，同样的状态渲染出来的UI也是一样。</p><p><strong>而setState并不会对状态进修改，而是新建一个空间来存储新的状态，同时会触发组件自上而下递归更新。</strong></p><p><a name="ojfUU"></a></p><h2 id="_27-react-fiber中断任务时-为啥能保存状态" tabindex="-1">27. react fiber中断任务时，为啥能保存状态？ <a class="header-anchor" href="#_27-react-fiber中断任务时-为啥能保存状态" aria-hidden="true">#</a></h2><p>可以从<code>fiber双缓存</code>和fiber节点指针指向来讲。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650714482740-b2bae887-8bdc-4e0e-bbac-ebe70afdbb26.png" alt="image.png"><br>fiber增加了节点指针，可以通过指针找到父节点和兄弟节点**，同时用循环代替了递归**，循环终止比递归更加高效方便。 <br>而fiber双缓存概念，一个React应用中存在两个fiber树，<code>currentFiber树</code> 和 <code>workInProgress Fiber树</code>，当任务重新执行时，会从对应的<code>currentFIber</code>中克隆出<code>Update对象</code>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650714810818-bbf90248-f9d9-4aac-8f80-5c64485ad333.png" alt="image.png"><a name="F8XOg"></a></p><h2 id="_28-requestidlecallback" tabindex="-1">28. requestIdleCallback <a class="header-anchor" href="#_28-requestidlecallback" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650716499419-c6ee5008-e456-41e6-ab3e-6856ea495363.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650716573617-471d6918-f109-488d-81c2-661aae9ec125.png" alt="image.png"><br>requestIdleCallback中的回调，会在浏览器空闲时被调用，在一帧当中剩余的时间再调用。</p><p>一帧包含了<code>用户的交互</code>、<code>js的执行</code>、以及<code>requestAnimationFrame的调用</code>，<code>布局计算</code>以及<code>页面的重绘</code>等工作。<br>假如某一帧里面要执行的任务不多，在不到16ms（1000/60)的时间内就完成了上述任务的话，那么这一帧就会有一定的空闲时间，这段时间就恰好可以用来执行requestIdleCallback的回调<br><a href="https://segmentfault.com/a/1190000014457824" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000014457824</a></p><p><a name="ydr10"></a></p><h2 id="_29-帧的概念-react里与浏览器之前关系" tabindex="-1">29. 帧的概念，react里与浏览器之前关系？ <a class="header-anchor" href="#_29-帧的概念-react里与浏览器之前关系" aria-hidden="true">#</a></h2><p>每秒<strong>帧数</strong>实际上就是指动画或视频每秒放映的画面数，帧就是<code>画面数</code>。每一帧都是静止的图象,快速连续地显示帧便形成了运动的假象。高的帧率可以得到更流畅、更逼真的动画。每秒钟帧数 (fps) 愈多,所显示的动作就会愈流畅。<br>通常我们屏幕的刷新率为<code>60hz</code>，1s刷新60次，1s可以有60帧，那么1帧可以理解为<code>16.6ms</code>，当前帧切换到下一帧的时间为<code>16.6ms</code>。</p><p><a name="INKpC"></a></p><h2 id="_30-vue的模版语法-实现静态编译-这个该怎么理解" tabindex="-1">30. vue的模版语法，实现静态编译，这个该怎么理解？ <a class="header-anchor" href="#_30-vue的模版语法-实现静态编译-这个该怎么理解" aria-hidden="true">#</a></h2><blockquote><p>另一方面vue能实现依赖收集得益于它的模版语法，实现静态编译，这是使用更灵活的JSX语法的react做不到的。</p></blockquote><p>这句话可以从Vue的<code>模版语法</code> 相较于 <code>jsx</code> 的优势来说，vue的模版语法在编译时会进行一些优化，如<code>静态提升</code>。</p><p>那么什么是静态提升呢？当 Vue 的编译器在编译过程中，**发现了一些不会变的节点或者属性，就会给这些节点打上标记。 **然后编译器在生成代码字符串的过程中(ast转为代码)，会发现这些静态的节点，并提升它们，将他们序列化成字符串，<strong>以此减少编译及渲染成本。有时可以跳过一整棵树。</strong></p><p>在编译阶段，发现一些不会变动的节点和属性，将其提升的静态节点，保存为html字符串，不会被转为渲染函数。 所以在执行render函数时，不会生成VNode，VNode树的节点会变少，优化了diff比对。真是因为这样的优化，可以减少编译和每次渲染的成本。</p><p><strong>模版语法可以在编译器中做性能优化，实现静态编译，为静态内容做优化，加速编译及减少渲染成本，所以它在访问状态收集依赖方面会更加高效，而jsx却享受不到这个静态优化，所以模版语法比jsx更加高效，依赖收集也更加高效。</strong></p><p><a name="f1uFt"></a></p><h2 id="_31-redux" tabindex="-1">31. redux <a class="header-anchor" href="#_31-redux" aria-hidden="true">#</a></h2><p><a name="Iw3C0"></a></p><h3 id="出现背景" tabindex="-1">出现背景： <a class="header-anchor" href="#出现背景" aria-hidden="true">#</a></h3><p>Redux是一个用来<strong>管理数据状态</strong>的库。随着JavaScript单页应用开发日趋复杂，JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。<br>在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。<strong>但 React 中组件间通信的数据流是单向的</strong>，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。<strong>这样简单的单向数据流支撑起了 React 中的数据可控性。</strong><br>组件嵌套过多时，组件可能需要一层层传递数据，多个组件通信起来较于麻烦，状态难以管控，所以<code>Redux</code>用来<strong>管理全局的状态，集中管理数据，实现组件间数据共享。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12388054/1622476571552-731d9a76-0bac-49c2-9d9a-d0076ae36b8f.png" alt="redux原理图.png"><a name="WF3O3"></a></p><h3 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12388054/1650864364252-f95922af-cdd7-4a6e-87b6-c869d6b618a7.png" alt="image.png"><br>简单的来讲，redux就是一个管理状态的库，定义了许多概念，store用来存储数据、进行调度更新，dispatch用来触发一个更新状态的操作，action用来描述更新的动作，reducer用来真正执行状态的更新。 而又依据<strong>发布订阅</strong>模式，当状态更新后，可以通知具体的订阅者，来执行一些操作。在React中，需要在状态更新后触发组件重新render，获取新的状态。</p><p><a name="yYJsc"></a></p><h3 id="react-redux" tabindex="-1">react-redux <a class="header-anchor" href="#react-redux" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12388054/1622476699744-cfb97142-8522-4faf-9549-7624d8f46261.png" alt="react-redux模型图.png"></p><p>react-redux是基于redux进行封装的，状态管理的核心还是redux。react-redux只是为了更加适用于react，redux内部使用Context 传递store。然后使用HOC高阶组件 组合具体的UI组件，在HOC内部获取Context上的state，以及更新dispatch方法。 <br>那么在使用Connect这个高阶组件时，需要向HOC传入props的key，以及具体的action，就是函数的调用，参数传递。 最终将 store的state和dispatch方法通过props的形式传入到具体UI组件中，这样在UI组件中就不需要操作具体的redux的API。<br>并且react-redux内部会订阅redux的状态变化，然后内部帮我们执行 <code>foreupdate</code>，组件重新render。</p><p><a name="fk2bt"></a></p><h2 id="_32-redux合并多个reducer" tabindex="-1">32. Redux合并多个reducer <a class="header-anchor" href="#_32-redux合并多个reducer" aria-hidden="true">#</a></h2><p>一个应用只允许有一个store，当状态复杂时，一个reducer会十分复杂臃肿，不利于后期开发维护。所以有必要将reducer拆分为多个子reducer，每个reducer进行独立的状态更新管理。<br>我们需要借助<code>combineReducers</code>来合并多个reducer，<code>combineReducers</code>就是一个函数，其实也可以理解为一个<code>reducer</code>，它组合多个<code>子reducer</code>，最终将所有reducer返回的state维护在一个对象中，放在store中进行管理。</p><p><strong>那么组合了多个reducer，当dispatch时，怎么确定执行对应的reduer呢？</strong><br>其实当store只有一个reducer时，而<code>action</code>这个结构，只表明操作state的行为，并不会定义操作哪个具体的reducer，sotre内部会遍历所有的reducer，由于reduer内部会有<code>swtich case</code>的逻辑，若当前<code>action</code>不能命中逻辑，则是不会更新state的。</p><p>那么多个reducer的情况也是如此，内部会遍历所有的reducer，reducer命中了action，才会更新状态。</p><p><a name="SV9eD"></a></p><h2 id="-1" tabindex="-1"><br> <a class="header-anchor" href="#-1" aria-hidden="true">#</a></h2></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-cfb513e0 data-v-21f75714><!----><div class="prev-next" data-v-21f75714><div class="pager" data-v-21f75714><!----></div><div class="pager" data-v-21f75714><a class="pager-link next" href="/blog/react-learning.html" data-v-21f75714><span class="desc" data-v-21f75714>Next page</span><span class="title" data-v-21f75714>React知识点</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"c41e2db0\",\"other-learning.md\":\"05bf5d6d\",\"react-learning.md\":\"fd19e56c\",\"vue-learning.md\":\"2b6ee216\"}")</script>
    <script type="module" async src="/assets/app.e3fac29c.js"></script>
    
  </body>
</html>